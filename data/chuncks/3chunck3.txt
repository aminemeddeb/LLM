its size and content varies depending on the adopted algorithm it always consists of a sequence number necessary for replay protection Message Authentication Code the output of the cryptographic function which allows the receiver to verify the authenticity and integrity properties of the message its size depends on the symmetric algorithm utilized The protection from message replay is guaranteed through the usage of an authenticated sequence number added to every message of service instances operating at both authentication andcondentiality level Being SOMEIP usable both on top5 of reliable and unreliable transport protocols it is possible to assist to message losses and reordering hence a sliding window technique is adopted Finally the proposed message format is fully compatible with vanilla SOMEIP applications a traditional device can interact with all the existing services provided that the nosec security level is allowed IV E XPERIMENTAL EVALUATION To evaluate the validity of the approach proposed the security framework has been implemented as a PoC integrating the designed functionalities within vsomeip For the sake of simplicity the cryptographic data has been assumed to be protected by means of operating system facilities However strong protection would require a hardware support to prevent both the access to the private keys from malicious parties and the alteration of the root certicate The source code of the PoC is publicly available on GitHub2 A Benchmark methodology The benchmarking process concentrated on the two main phases of the proposed security protocol First we considered the penalties introduced by the session establishment phase measuring the time required by an application to access the desired services hence assessing how the solution can scale when increasing the number of services Second we evaluated the runtime protection phase two applications communicating through the vsomeip framework were used to evaluate the difference between the available security levels in terms of message round trip times RTTs served requests per second and CPU load Three different strategies were adopted to achieve this goal First we assessed the latency introduced in the communication by the proposed security protocol measuring the time elapsed from the very beginning of a request to the reception of the corresponding response Hence the output measure includes both the latency introduced by the framework and the one due to the transmission across the network Second we evaluated to which degree the different security measures impacted the number of requests an offerer can serve in a given unit of time Differently from the previous evaluation scenario the client has been congured to perform a high number of requests in parallel and at the highest possible pace overloading both the requester and the offerer devices In this case the total time required to answer all the requests was used to compute the number of served requests ie the corresponding response has been received by the client per each second Last the alternative communication pattern publishsubscribe was considered to verify whether the usage of notications alters the results obtained with the previous techniques As a complement of the previous benchmarks we also evaluated the amount of CPU used by the requester while sending and receiving the messages Although the presented measurements are referred to the client application denitely similar results are expected to be associated with the offerer being in charge of performing the exact same operations 2httpsgithubcomnetgrouppolitosecurevsomeip 3264128256512102420484096819216384 1 2 4 8 16 32 64 128 256 Total elapsed time m sec of concurrent session establishmentsFig 5 Evaluation of the time required to concurrently complete multiple session establishments varying the handshake parallelism the dotted line represents a reference corresponding to a linear increase in the elapsed time Being embedded systems the target of the solution presented our testbed encompassed two identical NXPs development boards running an embedded Linux distribution and intercon nected by means of a Fast Ethernet link which represents the most common speed in the automotive environment They are based on the iMX 7Dual Applications Processor characterized by two ARM CortexA7 cores operating at up to 1 GHz and equipped with 1 GB of DDR3 RAM Concerning the session establishment phase the widely used RSA2048 asymmetric cryptosystem was chosen as a strong algorithm for encryption and digital signatures Each RTT benchmark on the other hand was executed both exploiting vanilla vsomeip taken as a reference and the PoC implementation considering all the three available security levels For what regards authentication and condentiality level services ChaCha20Poly1305 15 was picked up as the selected cryptographic algorithm thanks to its outstanding performance with embedded systems Appli cations based on the requestresponse pattern were executed considering all the three types of network bindings offered byvsomeip Unix domain sockets implementing local communication UDP and TCP Instead for what regards notications we limited our tests to UDP since it was the only option to support multicast communication Measurements were repeated with different payload lengths ranging from 1 to1024 bytes which are deemed to be quite representative of actually used values only the requests size was modied while the responses were always characterized by the absence of the payload B Numerical Results and Discussion Beginning with the analysis of the session establishment benchmark Fig 5 plots the total time required to complete multiple authentication handshakes in parallel when varying the amount of requested services The overall trend certies the scalability of the handshake phase by showing how the measured values do not tend to explode when increasing the number of services Indeed considering the dotted line displayed in the graph as a reference it becomes evident how the increase in the total time when doubling the number of concurrent session establishments is less than linear thanks6 050100150200250300350400 0153045 1 4 16 64 256 1024 RTT sec CPU Payload size bytes Vanilla vsomeip Nosec levelAuthentication level Condentiality level a 050010001500200025003000 015345 1 4 16 64 256 1024 RTT sec CPU Payload size bytes Vanilla vsomeip Nosec levelAuthentication level Condentiality level b Fig 6 RTT and CPU usage comparison between vanilla vsomeip and the securityenhanced version both in case of a local and b remote communication In b the uncertainty bands graphically overlap the top of the histogram bars being signicantly smaller than the RTT values ie