be leveraged to secure both unicast and multicast messages associated with a specic service instance The former alternative should provide a higher level of security guaranteeing a oneto one authentication of unicast messages and preventing directinteractions between different requesters Nonetheless a ma licious requester could anyway easily compromise the entire service directly triggering unwanted actions or transmitting counterfeit notications Hence as a tradeoff between security and complexity we adopted the second approach providing a grouplevel protection Symmetric keys are automatically generated by the framework every time a new service instance is started Thus each key is deemed to be used for a limited time signicantly reducing the possibilities for a successful attack Yet a rekeying mechanism might be required in case of longrunning services according to a wellestablished practice V S ECURITY PROTOCOL This section presents in great detail the security protocol at the core of our solution characterized by an initial handshake phase for session establishment followed by the transmission of secured messages After an initial set of denitions we proceed with a formal description of the security protocol laying the foundations for the subsequent formal verication The protocol will be described at symbolic level ie abstracting away some details of the cryptographic operations used eg the specic cryptographic algorithms or the key lengths This description is enough for the formal verication of the protocol logic according to the DolevYao approach 40 A Preliminaries In the following we dene the terminology adopted to formalize the security protocol herein presented For the sake of clarity and without loss of generality we temporarily assume the existence of a single service instance to be secured identied by the pair fsrvxinst xg Yet the protection can be trivially extended to the realistic case of multiple service instances coexisting in the same system Let Abe the single application authorized to offer fsrvxinst xg while fBig8i21n represents the set of requesters interested in accessing the given service instance for some n1 Additionally let us assume Abeing associated with a private keyskAand a digital certicate certA embedding both the corresponding public key pkAand an authorization policy A specied according to 2 for a given minimum security level Aamong nosec authentication andcondentiality Afsomeip srvxinstxofferAg 3 Similarly let each requester Bibe linked to a private key skBi and the related digital certicate certBifpkBiBig with Bifsomeip srvxinstxrequest Big 4 Additionally let certRidentify the root certicate Finally for a given service instance a security level slis said to be acceptable by an application if and only if sl whereis the minimum security level stated in the authorization policy For instance if AstatesAauthentication then both authentication andcondentiality levels would be acceptable forA Conversely nosec would not8 Algorithm 1 Session establishment Offerer A Requiresrvxinst xskAcert Acert R 1A getpolicy certAsrv xinst x 2sl securitylevel Auserconguration 3srvkey rndkey 4peerid 1 5loop 6 inRequestfsrv xinst xncert Big 7 iffsrv xinst xg6fsrvxinst xgor 8 notverifycert certBicert Rthen 9 abort 10 end if 11Bi getpolicy certBisrv xinst x 12 if not verifypolicy Birequestslthen 13 abort 14 end if 15pkBi getpubkey certBi 16enckey aenc srvkeypk Bi 17response srvxinst xncert Apeeridslenckey 18signature signresponsesk A 19 outResponsefresponsesignature g 20peerid peerid 1 21end loop B Session Establishment The rst pillar characterizing the security protocol proposed to protect SOMEIP communications consists of message handshakes to establish the secure sessions A handshake is transparently carried out by the framework between each application willing to access a specic service instance and the corresponding offerer Indeed although secure sessions operate at group level to account for onetomany communica tions each handshake is a onetoone authentication process performed independently between the application A offering fsrvxinst xg and each requester Bi8i21nien separate handshakes are performed by the framework at start up The entire handshake process is repeated for each unique service instance regardless of whether more instances are offered by the same or by different applications The session establishment phase serves two main purposes The rst purpose is to perform a mutual authentication and to ensure that each application accesses only service instances complying with the authorization policies stated by its corresponding digital certicate More precisely the framework automatically enforces the role associated with the application ie offer orrequest and veries whether the current security level of the service instance ie the one decided by the offerer as detailed in the following is acceptable In order to get the offerers authentication the offerer digitally signs its handshake response with its own private key and the requester veries this signature The requester on the other hand gets authenticated implicitly since it needs its private key to decipher and retrieve the symmetric key used for the subsequent run time protection The second purpose of the handshake is to share the session parameters between offerer and requester including the symmetric key transmitted in encrypted form Algorithms 1 and 2 formalize respectively the operations performed by the framework on behalf of the offerer Aand a requester Bito establish a secure session Each algorithm assumes to receive in input the service instance for which the handshake is to be performed ie fsrvxinst xg theAlgorithm 2 Session establishment Requester Bi Requiresrvxinst xskBicert Bicert R 1n nonce 2outRequestfsrvxinst xncert Big 3inResponsefresponsesignature g 4srv xinst xncert Apeeridslenckey response 5B getpolicy certBsrv xinst x 6iffsrv xinst xg6fsrvxinst xgorn6nor 7 notverifypolicy Brequestslor 8 notverifycert certAcert Rthen 9 abort 10end if 11A getpolicy certAsrv xinst x 12if not verifypolicy Aofferslthen 13 abort 14end if 15pkA getpubkey certA 16if not verifysignature signaturepk Athen 17 abort 18end if 19srvkey adec enckeysk Bi 20returnsrvkeypeerid private key and the digital certicate associated with the current application as well as the root certicate certR Focusing initially on the offerer upon startup the frame work selects a security level slA to be associated with the service instance compatibly with the corresponding authorization policy Aand optionally depending on a user dened conguration granted that it is acceptable Indeed an application developer may desire to select a security level higher than A in order to make it acceptable by a wider range of requesters Additionally the framework generates a new random symmetric key srvkey to be adopted for the runtime protection of fsrvxinst xg Indeed sticking to group protection