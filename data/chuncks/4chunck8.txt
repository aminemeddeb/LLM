both the MAC computation and the encryption of the payload containing sensible information securely exploiting10 SOMEIP HeaderSOMEIP PayloadSupport DataMACAuthenticated Encrypted Fig 3 Highlevel format of a secured SOMEIP message the same symmetric key In case the security level is different from nosec a sequence number snfpeeridseqg composed of the peer identier and a monotonic counter is appended to each message to detect possible replay attempts its integrity is effectively guaranteed by means of the MAC Accounting for message losses and reordering typical of unreliable transport protocols eg UDP we adopted a sliding window technique similar to the one used by Datagram Transport Layer Security DTLS 41 In particular it records the last subset of sequence numbers already received to discard the duplicates Additionally the sequence number is also leveraged as an initialization vector adopted by the cryptographic algorithms to introduce a bit of randomness in the computation Yet some algorithms specically require a completely random seed in those cases a random value would need to be generated and appended to every secured SOMEIP packet The highlevel format of a secured message is depicted in Fig 3 Most notably it encompasses two main elements in addi tion to vanilla SOMEIP packets First Support Data including the sequence number the initialization vector if different from the sequence number and any other additional information Second MAC corresponding to the output returned by the cryptographic algorithm and leveraged to ensure the authenticity and integrity of the entire SOMEIP message Accounting for the constraints imposed by the SOMEIP standard on extensions the two additional elds shall not exceed 56 bytes in total VI F ORMAL VERIFICATION This section presents the main aspects of the formal verication we performed to validate the security protocol herein proposed We start with a brief overview about why formal verication is adopted before presenting the main modelling choices Finally we conclude discussing the security properties formally veried and outlining the results obtained A Overview Formal verication is a technique used to thoroughly analyze communication protocols To this end we leveraged it to verify the absence of logical aws in our security protocol ie to prove that no attacks are possible under certain modeling assumptions In our analysis we exploited the DolevYao formal modeling technique and Proverif 42 an automatic crypto graphic protocol verier based on this technique According to this approach the attacker which is automatically modeled by the tool has complete control over the communication channel Additionally cryptography is considered ideal focusing on the conceptual properties while abstracting away the lowlevel details of the actual algorithmsPractically speaking to use Proverif it is necessary to formally express the cryptographic primitives adopted as well as the behavior of the trusted actors of the protocol by means of extended pi calculus Then the security properties eg secrecy and authentication to be formally veried can be specied by means of queries Sticking to an abstract approach we decided not to model the three different security levels Indeed being the security level at which a service instance operates autonomously selected by the offerer depending on its security policy a DolevYao attacker would have no meaningful ways to force a downgrade Therefore we modeled the properties associated with the condentiality level in order to verify the effectiveness of all the considered security guarantees In the following we present the most relevant aspects concerning the formal verication performed to prove the correctness of the security protocol proposed Yet the complete model expressed in extended pi calculus is publicly available on GitHub3 B Modeling Cryptography According to standard practice we modeled the highlevel operations associated with both symmetric and asymmetric en cryption as well as digital signatures Most notably depending on how rewrite rules work the former corresponds to authen ticated encryption since decryption fails in case of tampered messages Additionally we introduced initialization vectors to make two identical encrypted payloads indistinguishable by an attacker Concerning digital certicates we modeled them as a container binding together a public key the identier of a service instances are omitted for the sake of simplicity and a role among offer andrequest Certicate issuance is implemented through a private function ie executable only by trusted entities to model the impossibility for an attacker to forge digital certicates Finally random nonces and counters are represented in Proverif by fresh values ie values that are initially unknown and unguessable by an attacker C Trusted Protocol Actors As attackers are automatically modeled by Proverif we created two different processes to model the legitimate actors They represent the behavior of the offerer and the requester during the session establishment phase according to Algo rithms 1 and 2 Additionally we also modeled a simple runtime communication necessary to express certain security queries eg verify whether the requester correctly deciphered the symmetric key corresponding to client authentication In a nutshell the requester encrypts a message using the symmetric key previously exchanged and a fresh initialization vector sends it to the offerer that tries to decrypt it Finally a third process performs initialization tasks ie creates the private keys and issues the digital certicates associated with the legitimate parties Moreover it generates a valid private key and digital certicate stating a different service and makes it available to the attacker Hence Proverif can verify that a given entity cannot access a specic service even if he has access to a different one In the end the initializer starts the execution of an unbounded number of offerers and requesters in parallel 3httpsgithubcomnetgrouppolitosecurevsomeip11 D Security Properties Concerning the queries formally veried by Proverif we expressed the following i Secrecy of srvkey the sym metric key adopted for the runtime protection cannot be obtained or derived by the attacker ii Server authentication an attacker cannot impersonate the offerer without being detected by the requester In other words if a requester believes to have completed a server authentication with a given entity ie event endoffauth is triggered then the corresponding offerer must have actually started it ie event beginoffauth must have been previously exe cuted Specically the tool veries the injective correspon dence between the two events to require that each occur rence of the former